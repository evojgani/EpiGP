library(BGLR)
data(wheat)
m <- Recodemarkers(wheat.X)
rownames(m) <- names(wheat.Y[,1])
d <- read.csv("C:/Users/Elaheh/Documents/GBLUP MAZE/wheat_simulated_pheno.csv")
pheno <- d[,7]
names(pheno) <- rownames(m)
G_ERRBLUP <- Gall(m, cores=15)
G <- G_ERRBLUP$G
N <- length(pheno)
n <- 60
test <- sample(1:N,n)
training <- (1:N)[-test]
pheno_train <- pheno[training]
Pred_ERRBLUP <- ERRBLUP(pheno_train, G)
names(Pred_ERRBLUP) <- names(pheno)
cor(Pred_ERRBLUP[test], pheno[test])
pheno[test]
Pred_ERRBLUP[test]
pheno <- wheat.Y[,1]
training <- (1:N)[-test]
pheno_train <- pheno[training]
Pred_ERRBLUP <- ERRBLUP(pheno_train, G)
names(Pred_ERRBLUP) <- names(pheno)
cor(Pred_ERRBLUP[test], pheno[test])
library(BGLR)
data(wheat)
pheno <- wheat.Y[,1]
m <- Recodemarkers(wheat.X)
rownames(m) <- names(pheno)
G_ERRBLUP <- Gall(m, cores=15)
G <- G_ERRBLUP$G
N <- length(pheno)
n <- 60
test <- sample(1:N,n)
training <- (1:N)[-test]
pheno_train <- pheno[training]
Pred_ERRBLUP <- ERRBLUP(pheno_train, G)
cor(Pred_ERRBLUP[test], pheno[test])
names(Pred_ERRBLUP) <- names(pheno)
cor(Pred_ERRBLUP[test], pheno[test])
G <- G_ERRBLUP$G
pi <- G_ERRBLUP$Pi
t_hat <- SNP_effect(m, pheno_train, G, pi, training, cores=15)
sigma_hat <- SNP_var(m, t_hat, cores=15)
k <- 10
Gtop_effect <- Gtop(m, t_hat, k, cores=15)
Gtop_var <- Gtop(m, sigma_hat, k, cores=15)
sERRBLUP_effect <- sERRBLUP(pheno_train, Gtop_effect)
sERRBLUP_var <- sERRBLUP(pheno_train, Gtop_var)
cor(Pred_ERRBLUP[test], pheno[test])
cor(sERRBLUP_effect [test], pheno[test])
cor(sERRBLUP_var [test], pheno[test])
library(EpiGP)
library(BGLR)
data(wheat)
pheno <- wheat.Y[,3]
m <- Recodemarkers(wheat.X)
rownames(m) <- names(pheno)
G_ERRBLUP <- Gall(m, cores=15)
G <- G_ERRBLUP$G
N <- length(pheno)
n <- 60
test <- sample(1:N,n)
training <- (1:N)[-test]
pheno_train <- pheno[training]
Pred_ERRBLUP <- ERRBLUP(pheno_train, G)
cor(Pred_ERRBLUP[test], pheno[test])
pi <- G_ERRBLUP$Pi
t_hat <- SNP_effect(m, pheno_train, G, pi, training, cores=15)
sigma_hat <- SNP_var(m, t_hat, cores=15)
k <- 10
Gtop_effect <- Gtop(m, t_hat, k, cores=15)
Gtop_var <- Gtop(m, sigma_hat, k, cores=15)
sERRBLUP_effect <- sERRBLUP(pheno_train, Gtop_effect)
sERRBLUP_var <- sERRBLUP(pheno_train, Gtop_var)
cor(Pred_ERRBLUP[test], pheno[test])
cor(sERRBLUP_effect [test], pheno[test])
cor(sERRBLUP_var [test], pheno[test])
m <- m[, 1:100]
dim(m)
pheno <- wheat.Y[,3]
N <- length(pheno)
n <- 60
test <- sample(1:N,n)
training <- (1:N)[-test]
pheno_train <- pheno[training]
G_ERRBLUP <- Gall(m, cores=15)
G <- G_ERRBLUP$G
pi <- G_ERRBLUP$Pi
t_hat <- SNP_effect(m, pheno_train, G, pi, training, cores=15)
sigma_hat <- SNP_var(m, t_hat, cores=15)
k <- 10
Gtop_effect <- Gtop(m, t_hat, k, cores=15)
Gtop_var <- Gtop(m, sigma_hat, k, cores=15)
sERRBLUP_effect <- sERRBLUP(pheno_train, Gtop_effect)
sERRBLUP_var <- sERRBLUP(pheno_train, Gtop_var)
Pred_ERRBLUP <- ERRBLUP(pheno_train, G)
cor(Pred_ERRBLUP[test], pheno[test])
cor(sERRBLUP_effect [test], pheno[test])
cor(sERRBLUP_var [test], pheno[test])
library(BGLR)
data(wheat)
m <- Recodemarkers(wheat.X)
rownames(m) <- names(wheat.Y[,1])
d <- read.csv("C:/Users/Elaheh/Documents/GBLUP MAZE/wheat_simulated_pheno.csv")
pheno <- d[,7]
names(pheno) <- rownames(m)
N <- length(pheno)
n <- 60
test <- sample(1:N,n)
training <- (1:N)[-test]
pheno_train <- pheno[training]
G_ERRBLUP <- Gall(m, cores=15)
G <- G_ERRBLUP$G
pi <- G_ERRBLUP$Pi
t_hat <- SNP_effect(m, pheno_train, G, pi, training, cores=15)
sigma_hat <- SNP_var(m, t_hat, cores=15)
k <- 1
Gtop_effect <- Gtop(m, t_hat, k, cores=15)
Gtop_var <- Gtop(m, sigma_hat, k, cores=15)
Pred_ERRBLUP <- ERRBLUP(pheno_train, G)
sERRBLUP_effect <- sERRBLUP(pheno_train, Gtop_effect)
sERRBLUP_var <- sERRBLUP(pheno_train, Gtop_var)
cor(Pred_ERRBLUP[test], pheno[test])
cor(sERRBLUP_effect [test], pheno[test])
cor(sERRBLUP_var [test], pheno[test])
Gall_correct <- function(M, cores=1){
RandomFieldsUtils::RFoptions(cores=cores)
Z <- t(M)
nsnp <- nrow(Z)
nindi <- ncol(Z)
# Sequential computation of the genomic relation ship matrix
G <- matrix(0, ncol=nindi, nrow=nindi)
storage.mode(Z) = "integer"
attr(Z, "dimnames") = NULL
Z0 <- (Z==0)*2L
Z2 <- (Z==2)*2L
p_i <- rep(NA, nsnp*nsnp*4)
Z_share = matrix(0L, ncol=nindi, nrow=(nsnp)*4)
for(index in nsnp:1){
print(index)
temp1 = matrix(Z[index,]==0, ncol=nindi, nrow=nsnp-index+1, byrow=TRUE)
temp2 = Z0[index:nsnp,,drop=FALSE]
temp3 = Z2[index:nsnp,,drop=FALSE]
Z_share[index:nsnp,] <- temp1 * temp2
Z_share[index:nsnp + nsnp,] <- (!temp1) * temp2
Z_share[index:nsnp + 2*nsnp,] <- temp1 * temp3
Z_share[index:nsnp + 3*nsnp,] <- (!temp1) * temp3
if(index!=1){
Z_miraculix <- miraculix::genomicmatrix(Z_share[-c(1:(index-1), 1:(index-1)+nsnp, 1:(index-1)+2*nsnp, 1:(index-1)+3*nsnp),])
p_i[((index-1)*nsnp*4+1):((index)*nsnp*4)][-c(1:(index-1), 1:(index-1)+nsnp, 1:(index-1)+2*nsnp, 1:(index-1)+3*nsnp)] <- miraculix::allele_freq(Z_miraculix)
} else{
Z_miraculix <- miraculix::genomicmatrix(Z_share)
p_i[((index-1)*nsnp*4+1):((index)*nsnp*4)] <- miraculix::allele_freq(Z_miraculix)
}
G <- G +  miraculix::relationshipMatrix(Z_miraculix, centered=FALSE, normalized=FALSE)
}
p_i <- p_i[complete.cases(p_i)]
length(p_i)
G_all <- G
rownames(G_all) <- rownames(M)
colnames(G_all) <- rownames(M)
out <- list(G = G_all, pi = p_i)
return(out)
}
SNP_effect_correct <- function(M, phenosid, Gall, p_i, val, cores=1){
RandomFieldsUtils::RFoptions(cores=cores)
Z <- t(M)
y <- phenosid[!val,2]
ntrain <- length(y)
multi  <-  y - mean(y)
nsnp <- nrow(Z)
nindi <- ncol(Z)
# rrBLUP
R <- diag(ntrain)
training <- !val
Gtrain <- Gall[training,training]
abc <- emmreml(y=y, X=cbind(matrix(1, nrow = ntrain, ncol=1)), Z=diag(ntrain), K=Gtrain)
vare <- abc$Ve
varg <- abc$Vu
lambda <- vare/varg
if(lambda<0.001){
lambda = 0.001
}
if(lambda>1000){
lambda = 1000
}
Rest_term <- (chol2inv(chol(Gtrain + R *lambda)) %*% multi)
# this is cheating since i am assuming the heritability to be known but will not cost a lot of computation time
Z0 <- (Z==0)*2L
Z2 <- (Z==2)*2L
u_hat <- numeric(nsnp*nsnp*4)
Z_share = matrix(0L, ncol=nindi, nrow=nsnp*4)
for(index in nsnp:1){
print(index)
temp1 = matrix(Z[index,]==0, ncol=nindi, nrow=nsnp-index+1, byrow=TRUE)
temp2 = Z0[index:nsnp,,drop=FALSE]
temp3 = Z2[index:nsnp,,drop=FALSE]
Z_share[index:nsnp,] <- temp1 * temp2
Z_share[index:nsnp + nsnp,] <- (!temp1) * temp2
Z_share[index:nsnp + 2*nsnp,] <- temp1 * temp3
Z_share[index:nsnp + 3*nsnp,] <- (!temp1) * temp3
Z_miraculix <- miraculix::genomicmatrix(Z_share[,training])
u_hat[((index-1)*nsnp*4+1):((index)*nsnp*4)] <- miraculix::genoVector(Z_miraculix, Rest_term)
}
u_hat <- u_hat  * 1/ 2 / sum(p_i*(1-p_i))
return(u_hat)
}
Gtop_effect_correct <- function(M, SNPeffect, k, cores=1){
RandomFieldsUtils::RFoptions(cores=cores)
Z <- t(M)
nsnp <- nrow(Z)
nindi <- ncol(Z)
# Sequential computation of the genomic relation ship matrix
G <- matrix(0, ncol=nindi, nrow=nindi)
storage.mode(Z) = "integer"
attr(Z, "dimnames") = NULL
Z0 <- (Z==0)*2L
Z2 <- (Z==2)*2L
p_i <- rep(NA, nsnp*nsnp*4)
include <- integer((nsnp*nsnp*4))+1L
include[abs(SNPeffect)< stats::quantile(abs(SNPeffect),(1-(k/100)))] <- 0L
rm(SNPeffect)
check = prod(include)
Z_share = matrix(0L, ncol=nindi, nrow=nsnp*4)
for(index in nsnp:1){
print(index)
temp1 = matrix(Z[index,]==0, ncol=nindi, nrow=nsnp-index+1, byrow=TRUE)
temp2 = Z0[index:nsnp,,drop=FALSE]
temp3 = Z2[index:nsnp,,drop=FALSE]
Z_share[index:nsnp,] <- temp1 * temp2
Z_share[index:nsnp + nsnp,] <- (!temp1) * temp2
Z_share[index:nsnp + 2*nsnp,] <- temp1 * temp3
Z_share[index:nsnp + 3*nsnp,] <- (!temp1) * temp3
if(check!=1){
Z_share <- matrix(include[((index-1)*nsnp*4+1):((index)*nsnp*4)], ncol=nindi, nrow=nsnp*4, byrow=FALSE) * Z_share
}
if(index!=1){
Z_miraculix <- miraculix::genomicmatrix(Z_share[-c(1:(index-1), 1:(index-1)+nsnp, 1:(index-1)+2*nsnp, 1:(index-1)+3*nsnp),])
p_i[((index-1)*nsnp*4+1):((index)*nsnp*4)][-c(1:(index-1), 1:(index-1)+nsnp, 1:(index-1)+2*nsnp, 1:(index-1)+3*nsnp)] <- miraculix::allele_freq(Z_miraculix)
} else{
Z_miraculix <- miraculix::genomicmatrix(Z_share)
p_i[((index-1)*nsnp*4+1):((index)*nsnp*4)] <- miraculix::allele_freq(Z_miraculix)
}
G <- G +  miraculix::relationshipMatrix(Z_miraculix, centered=FALSE, normalized=FALSE)
}
p_i <- p_i[complete.cases(p_i)]
G_k <- G / (2 * sum(p_i*(1-p_i)))
rownames(G_k) <- rownames(M)
colnames(G_k) <- rownames(M)
return(G_k)
}
G_ERRBLUP1 <- Gall_correct(m, cores=15)
G1 <- G_ERRBLUP1$G
pi1 <- G_ERRBLUP1$Pi
t_hat1 <- SNP_effect_correct(m, pheno, G1, pi1, test, cores=15)
k <- 1
Gtop_effect1 <- Gtop(m, t_hat1, k, cores=15)
Pred_ERRBLUP1 <- ERRBLUP(pheno_train, G1)
sERRBLUP_effect1 <- sERRBLUP(pheno_train, Gtop_effect1)
cor(Pred_ERRBLUP[test], pheno[test])
cor(sERRBLUP_effect [test], pheno[test])
phenosid <-  data.frame(ID = names(pheno),observation = pheno)
SNP_effect_correct <- function(M, phenosid, Gall, p_i, val, cores=1){
RandomFieldsUtils::RFoptions(cores=cores)
Z <- t(M)
y <- phenosid[!val,2]
ntrain <- length(y)
multi  <-  y - mean(y)
nsnp <- nrow(Z)
nindi <- ncol(Z)
# rrBLUP
R <- diag(ntrain)
training <- !val
Gtrain <- Gall[training,training]
abc <- emmreml(y=y, X=cbind(matrix(1, nrow = ntrain, ncol=1)), Z=diag(ntrain), K=Gtrain)
vare <- abc$Ve
varg <- abc$Vu
lambda <- vare/varg
if(lambda<0.001){
lambda = 0.001
}
if(lambda>1000){
lambda = 1000
}
Rest_term <- (chol2inv(chol(Gtrain + R *lambda)) %*% multi)
# this is cheating since i am assuming the heritability to be known but will not cost a lot of computation time
Z0 <- (Z==0)*2L
Z2 <- (Z==2)*2L
u_hat <- numeric(nsnp*nsnp*4)
Z_share = matrix(0L, ncol=nindi, nrow=nsnp*4)
for(index in nsnp:1){
print(index)
temp1 = matrix(Z[index,]==0, ncol=nindi, nrow=nsnp-index+1, byrow=TRUE)
temp2 = Z0[index:nsnp,,drop=FALSE]
temp3 = Z2[index:nsnp,,drop=FALSE]
Z_share[index:nsnp,] <- temp1 * temp2
Z_share[index:nsnp + nsnp,] <- (!temp1) * temp2
Z_share[index:nsnp + 2*nsnp,] <- temp1 * temp3
Z_share[index:nsnp + 3*nsnp,] <- (!temp1) * temp3
Z_miraculix <- miraculix::genomicmatrix(Z_share[,training])
u_hat[((index-1)*nsnp*4+1):((index)*nsnp*4)] <- miraculix::genoVector(Z_miraculix, Rest_term)
}
u_hat <- u_hat  * 1/ 2 / sum(p_i*(1-p_i))
return(u_hat)
}
Gtop_effect_correct <- function(M, SNPeffect, k, cores=1){
RandomFieldsUtils::RFoptions(cores=cores)
Z <- t(M)
nsnp <- nrow(Z)
nindi <- ncol(Z)
# Sequential computation of the genomic relation ship matrix
G <- matrix(0, ncol=nindi, nrow=nindi)
storage.mode(Z) = "integer"
attr(Z, "dimnames") = NULL
Z0 <- (Z==0)*2L
Z2 <- (Z==2)*2L
p_i <- rep(NA, nsnp*nsnp*4)
include <- integer((nsnp*nsnp*4))+1L
include[abs(SNPeffect)< stats::quantile(abs(SNPeffect),(1-(k/100)))] <- 0L
rm(SNPeffect)
check = prod(include)
Z_share = matrix(0L, ncol=nindi, nrow=nsnp*4)
for(index in nsnp:1){
print(index)
temp1 = matrix(Z[index,]==0, ncol=nindi, nrow=nsnp-index+1, byrow=TRUE)
temp2 = Z0[index:nsnp,,drop=FALSE]
temp3 = Z2[index:nsnp,,drop=FALSE]
Z_share[index:nsnp,] <- temp1 * temp2
Z_share[index:nsnp + nsnp,] <- (!temp1) * temp2
Z_share[index:nsnp + 2*nsnp,] <- temp1 * temp3
Z_share[index:nsnp + 3*nsnp,] <- (!temp1) * temp3
if(check!=1){
Z_share <- matrix(include[((index-1)*nsnp*4+1):((index)*nsnp*4)], ncol=nindi, nrow=nsnp*4, byrow=FALSE) * Z_share
}
if(index!=1){
Z_miraculix <- miraculix::genomicmatrix(Z_share[-c(1:(index-1), 1:(index-1)+nsnp, 1:(index-1)+2*nsnp, 1:(index-1)+3*nsnp),])
p_i[((index-1)*nsnp*4+1):((index)*nsnp*4)][-c(1:(index-1), 1:(index-1)+nsnp, 1:(index-1)+2*nsnp, 1:(index-1)+3*nsnp)] <- miraculix::allele_freq(Z_miraculix)
} else{
Z_miraculix <- miraculix::genomicmatrix(Z_share)
p_i[((index-1)*nsnp*4+1):((index)*nsnp*4)] <- miraculix::allele_freq(Z_miraculix)
}
G <- G +  miraculix::relationshipMatrix(Z_miraculix, centered=FALSE, normalized=FALSE)
}
p_i <- p_i[complete.cases(p_i)]
G_k <- G / (2 * sum(p_i*(1-p_i)))
rownames(G_k) <- rownames(M)
colnames(G_k) <- rownames(M)
return(G_k)
}
G_ERRBLUP1 <- Gall_correct(m, cores=15)
G1 <- G_ERRBLUP1$G
pi1 <- G_ERRBLUP1$Pi
t_hat1 <- SNP_effect_correct(m, pheno, G1, pi1, test, cores=15)
k <- 1
Gtop_effect1 <- Gtop(m, t_hat1, k, cores=15)
Pred_ERRBLUP1 <- ERRBLUP(pheno_train, G1)
sERRBLUP_effect1 <- sERRBLUP(pheno_train, Gtop_effect1)
cor(Pred_ERRBLUP[test], pheno[test])
cor(sERRBLUP_effect [test], pheno[test])
phenosid <-  data.frame(ID = names(pheno),observation = pheno)
val <- test
SNP_effect_correct <- function(M, phenosid, Gall, p_i, val, cores=1){
RandomFieldsUtils::RFoptions(cores=cores)
Z <- t(M)
y <- phenosid[!val,2]
ntrain <- length(y)
multi  <-  y - mean(y)
nsnp <- nrow(Z)
nindi <- ncol(Z)
# rrBLUP
R <- diag(ntrain)
training <- !val
Gtrain <- Gall[training,training]
abc <- emmreml(y=y, X=cbind(matrix(1, nrow = ntrain, ncol=1)), Z=diag(ntrain), K=Gtrain)
vare <- abc$Ve
varg <- abc$Vu
lambda <- vare/varg
if(lambda<0.001){
lambda = 0.001
}
if(lambda>1000){
lambda = 1000
}
Rest_term <- (chol2inv(chol(Gtrain + R *lambda)) %*% multi)
# this is cheating since i am assuming the heritability to be known but will not cost a lot of computation time
Z0 <- (Z==0)*2L
Z2 <- (Z==2)*2L
u_hat <- numeric(nsnp*nsnp*4)
Z_share = matrix(0L, ncol=nindi, nrow=nsnp*4)
for(index in nsnp:1){
print(index)
temp1 = matrix(Z[index,]==0, ncol=nindi, nrow=nsnp-index+1, byrow=TRUE)
temp2 = Z0[index:nsnp,,drop=FALSE]
temp3 = Z2[index:nsnp,,drop=FALSE]
Z_share[index:nsnp,] <- temp1 * temp2
Z_share[index:nsnp + nsnp,] <- (!temp1) * temp2
Z_share[index:nsnp + 2*nsnp,] <- temp1 * temp3
Z_share[index:nsnp + 3*nsnp,] <- (!temp1) * temp3
Z_miraculix <- miraculix::genomicmatrix(Z_share[,training])
u_hat[((index-1)*nsnp*4+1):((index)*nsnp*4)] <- miraculix::genoVector(Z_miraculix, Rest_term)
}
u_hat <- u_hat  * 1/ 2 / sum(p_i*(1-p_i))
return(u_hat)
}
Gtop_effect_correct <- function(M, SNPeffect, k, cores=1){
RandomFieldsUtils::RFoptions(cores=cores)
Z <- t(M)
nsnp <- nrow(Z)
nindi <- ncol(Z)
# Sequential computation of the genomic relation ship matrix
G <- matrix(0, ncol=nindi, nrow=nindi)
storage.mode(Z) = "integer"
attr(Z, "dimnames") = NULL
Z0 <- (Z==0)*2L
Z2 <- (Z==2)*2L
p_i <- rep(NA, nsnp*nsnp*4)
include <- integer((nsnp*nsnp*4))+1L
include[abs(SNPeffect)< stats::quantile(abs(SNPeffect),(1-(k/100)))] <- 0L
rm(SNPeffect)
check = prod(include)
Z_share = matrix(0L, ncol=nindi, nrow=nsnp*4)
for(index in nsnp:1){
print(index)
temp1 = matrix(Z[index,]==0, ncol=nindi, nrow=nsnp-index+1, byrow=TRUE)
temp2 = Z0[index:nsnp,,drop=FALSE]
temp3 = Z2[index:nsnp,,drop=FALSE]
Z_share[index:nsnp,] <- temp1 * temp2
Z_share[index:nsnp + nsnp,] <- (!temp1) * temp2
Z_share[index:nsnp + 2*nsnp,] <- temp1 * temp3
Z_share[index:nsnp + 3*nsnp,] <- (!temp1) * temp3
if(check!=1){
Z_share <- matrix(include[((index-1)*nsnp*4+1):((index)*nsnp*4)], ncol=nindi, nrow=nsnp*4, byrow=FALSE) * Z_share
}
if(index!=1){
Z_miraculix <- miraculix::genomicmatrix(Z_share[-c(1:(index-1), 1:(index-1)+nsnp, 1:(index-1)+2*nsnp, 1:(index-1)+3*nsnp),])
p_i[((index-1)*nsnp*4+1):((index)*nsnp*4)][-c(1:(index-1), 1:(index-1)+nsnp, 1:(index-1)+2*nsnp, 1:(index-1)+3*nsnp)] <- miraculix::allele_freq(Z_miraculix)
} else{
Z_miraculix <- miraculix::genomicmatrix(Z_share)
p_i[((index-1)*nsnp*4+1):((index)*nsnp*4)] <- miraculix::allele_freq(Z_miraculix)
}
G <- G +  miraculix::relationshipMatrix(Z_miraculix, centered=FALSE, normalized=FALSE)
}
p_i <- p_i[complete.cases(p_i)]
G_k <- G / (2 * sum(p_i*(1-p_i)))
rownames(G_k) <- rownames(M)
colnames(G_k) <- rownames(M)
return(G_k)
}
G_ERRBLUP1 <- Gall_correct(m, cores=15)
G1 <- G_ERRBLUP1$G
pi1 <- G_ERRBLUP1$Pi
t_hat1 <- SNP_effect_correct(m, pheno, G1, pi1, test, cores=15)
k <- 1
Gtop_effect1 <- Gtop(m, t_hat1, k, cores=15)
Pred_ERRBLUP1 <- ERRBLUP(pheno_train, G1)
sERRBLUP_effect1 <- sERRBLUP(pheno_train, Gtop_effect1)
cor(Pred_ERRBLUP1[test], pheno[test])
cor(sERRBLUP_effect1 [test], pheno[test])
dim(phenosid)
phenosid[!val, 2]
phenosid[val, 2]
!val <- training
SNP_effect_correct <- function(M, phenosid, Gall, p_i, val, cores=1){
RandomFieldsUtils::RFoptions(cores=cores)
Z <- t(M)
training <- !val
y <- phenosid[training,2]
ntrain <- length(y)
multi  <-  y - mean(y)
nsnp <- nrow(Z)
nindi <- ncol(Z)
# rrBLUP
R <- diag(ntrain)
training <- !val
Gtrain <- Gall[training,training]
abc <- emmreml(y=y, X=cbind(matrix(1, nrow = ntrain, ncol=1)), Z=diag(ntrain), K=Gtrain)
vare <- abc$Ve
varg <- abc$Vu
lambda <- vare/varg
if(lambda<0.001){
lambda = 0.001
}
if(lambda>1000){
lambda = 1000
}
Rest_term <- (chol2inv(chol(Gtrain + R *lambda)) %*% multi)
# this is cheating since i am assuming the heritability to be known but will not cost a lot of computation time
Z0 <- (Z==0)*2L
Z2 <- (Z==2)*2L
u_hat <- numeric(nsnp*nsnp*4)
Z_share = matrix(0L, ncol=nindi, nrow=nsnp*4)
for(index in nsnp:1){
print(index)
temp1 = matrix(Z[index,]==0, ncol=nindi, nrow=nsnp-index+1, byrow=TRUE)
temp2 = Z0[index:nsnp,,drop=FALSE]
temp3 = Z2[index:nsnp,,drop=FALSE]
Z_share[index:nsnp,] <- temp1 * temp2
Z_share[index:nsnp + nsnp,] <- (!temp1) * temp2
Z_share[index:nsnp + 2*nsnp,] <- temp1 * temp3
Z_share[index:nsnp + 3*nsnp,] <- (!temp1) * temp3
Z_miraculix <- miraculix::genomicmatrix(Z_share[,training])
u_hat[((index-1)*nsnp*4+1):((index)*nsnp*4)] <- miraculix::genoVector(Z_miraculix, Rest_term)
}
u_hat <- u_hat  * 1/ 2 / sum(p_i*(1-p_i))
return(u_hat)
}
t_hat1 <- SNP_effect_correct(m, pheno, G1, pi1, test, cores=15)
t_hat1 <- SNP_effect_correct(m, phenosid, G1, pi1, test, cores=15)
library(EpiGP)
?sERRBLUP
